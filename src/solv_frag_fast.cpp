/*
*    This file is part of SEED.
*
*    Copyright (C) 2017, Caflisch Lab, University of Zurich
*
*    SEED is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    SEED is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include "nrutil.h"
#include "funct.h"

#include <stdlib.h>


void ElecFragFast(int ReAtNu,double **ReCoor,double *ReRadOut,double *ReRadOut2,
                 struct point *surfpt_re,int *nsurf_re,double *ReSurf_deso,
                 int *pointsrf_re,int ***nlist_re,int **list_re,int nstep_re,
                 struct point cbmid_re,int midg_re,double rscale_re,
                 int FrAtNu,double **RoSFCo,double **FrCoor,double *FrRad,
                 double *FrRadOut,double *FrRadOut2,double *FrMinC_orig,
                 double *FrMaxC_orig,double FrRmax,int Nsurfpt_fr,
                 struct point *surfpt_fr_orig,struct point *surfpt_fr,
                 int *nsurf_fr,double *FrSurf_deso,int *pointsrf_fr,
                 double Tr[4],double U1[4][4],double U2[4][4],
		 double WaMoRa,double rslop,int MaxNeigh,double *PReDesoElec, double *PFrDesoElec)
/*########################################################################
Continuum Electrostatics: it calculates the rec and frag desolvation.
Fast and approximate method
########################################################################*/

/*#######################################################################
int ReAtNu -------------- Tot # rec atoms
double **ReCoor ---------- Rec Coordinates
double *ReRadOut -------- Rec charge radii + WaMoRa
double *ReRadOut2 ------- (Rec charge radii + WaMoRa)^2

==============================================================================
                  SAS1 is a SAS built to obtain the volume enclosed by the MS
                  SAS2 is a SAS built for a fast evaluation of the desolvation
                  SAS3 is a SAS built to estimate the surface hydrophobicity
==============================================================================

struct point *surfpt_re - Coor of points over rec SAS2
int *nsurf_re ----------- nsurf_re[n] = amount of SAS2 surface points
                          generated by rec atom n
int *pointsrf_re -------- pointsrf_re[n] = first rec SAS2 point (in the
                          list surfpt_re) that is generated by rec atom n
int ***nlist_re --------- nlist_re[ix][iy][iz]: # of rec atoms associated with cube
                          grid point ix,iy,iz. It is a special grid created to
                          have a fast neighbour list for the fast desolvation
int **list_re ----------- list[m][n(ix,iy,iz)]: given the grid
                          point ix,iy,iz "list" tells which rec atom numbers are
                          associated with this point (m goes from
                          1 to nlist_re[ix][iy][iz] )
int nstep_re ------------ Dimension of the grid box for the rec neighbour list. It
                          is a cubic box of even elements on each side
struct point cbmid_re --- Coor of the center of the grid box for the
                          rec neighbour list
int midg_re ------------- nstep_re/2. + 1
double rscale_re -------- 2.*(MaximumRecChargeRadius + WaMoRa) + rslop
int FrAtNu -------------- Tot # frag atoms
double **RoSFCo ---------- Frag coordinates in the seeded conformation
double **FrCoor ---------- Frag coordinates in the original location
double *FrRad ----------- Frag charge radii (=vdW radii apart "enclosed" H)
double *FrRadOut -------- Frag charge radii + WaMoRa
double *FrRadOut2 ------- (Frag charge radii + WaMoRa)^2
double *FrMinC_orig ------ Min (along x,y,z) of FrCoor
double *FrMaxC_orig ------ Max (along x,y,z) of FrCoor
double FrRmax ----------- Max frag charge radius
int Nsurfpt_fr ---------- Tot # of points over the frag SAS2
struct point *surfpt_fr_orig - Coor of points over frag SAS2 (obtained from
                               FrCoor coordinates)
struct point *surfpt_fr - Coor of points over frag SAS2 (obtained from
                          RoSFCo coordinates)
int *nsurf_fr ----------- nsurf_fr[n] = amount of SAS2 surface points
                          generated by frag atom n
double **FrSurf_deso ---- FrSurf_deso[n] = Desolvation of a sphere placed
                          on the nth point of the frag SAS2
int *pointsrf_fr -------- pointsrf_re[n] = first frag SAS2 point (in the
                          list surfpt_fr) that is generated by frag atom n
double Tr[4] ------------ Translation vector to superimpose the first atom of
                          FrCoor with the first of RoSFCo
double U1[4][4] --------- Rotation matrix around the axis passing by the 1st atom
                          of FrCoor and perpendicular to the plane formed by the
                          vector joining the 1st atom and the 2nd atom of FrCoor
                          and the vector joining the 1st atom and the 2nd atom of
                          RoSFCo. The rotation angle is such that it superimpose
                          the 2nd atom of RoSFCo with the 2nd atom of FrCoor
double U2[4][4] --------- Rotation matrix around the axis joining the 1st atom and
                          the 2nd atom of RoSFCo in order to superimpose
                          the 3rd atom of RoSFCo with the 3rd atom of FrCoor

double WaMoRa ----------- Radius of the water molecule
double rslop ------------ Parameter introduced to define the grid box for the
                          neighbour list
int MaxNeigh ------------ Max # of atoms that can be associated to the same
                          neigh. list grid point. It is introduced to
                          facilitate memory allocation
double *PReDesoElec ----- Rec elec desolvation
double *PFrDesoElec ----- Frag elec desolvation
######################################################################*/
{
  int nstep_fr,midg_fr,***nlist_fr,**list_fr,nn;/* ,ntime; */
  double FrMinC[4],FrMaxC[4];
  double slen,rscale_fr,*vect;
  struct point cbmid_fr,len;
/*########################################################################
int nstep_fr ------------ Dimension of the grid box for the frag neighbour list.
                          It is a cubic box of even elements on each side
int midg_fr ------------- nstep_fr/2. + 1
int ****nlist_fr -------- nlist_fr[ix][iy][iz]: # of frag atoms associated with cube
                          grid point ix,iy,iz. It is a special grid created to
                          have a fast neighbour list for the fast desolvation
int ***list_fr ---------- list[m][n(ix,iy,iz)]: given the grid
                          point ix,iy,iz "list" tells which frag atom numbers are
                          associated with this point (m goes from
                          1 to nlist_fr[ix][iy][iz] )
int nn,ntime ------------ Multipurpose variable
double FrMinC[4] --------- Min (along x,y,z) of RoSFCo
double FrMaxC[4] --------- Max (along x,y,z) of RoSFCo
double slen ------------- Max dimension of the the grid box for the
                          frag neighbour list
double rscale_fr -------- 2.*(MaximumFragChargeRadius + WaMoRa) + rslop
struct point cbmid_fr --- Coor of the center of the grid box for the
                          frag neighbour list
struct point len -------- FrMaxC_orig - FrMinC_orig
########################################################################*/

/*  ntime = clock(); */

/* Translate and rotate the S&R surface of the fragment alone from the
   original position to the actual position */
  nn = Mov_surf(Nsurfpt_fr,surfpt_fr_orig,FrCoor,FrMinC_orig,FrMaxC_orig,
                Tr,U1,U2,surfpt_fr,FrMinC,FrMaxC);

/* Modification 18/10/99==============*/
  vect=dvector(1,FrAtNu);
  getColumnFrom2DArray(RoSFCo, 1, 1, FrAtNu, vect);
  FrMinC[1] = MinVector(vect, 1, FrAtNu);
  FrMaxC[1] = MaxDVector(vect, 1, FrAtNu);
  getColumnFrom2DArray(RoSFCo, 2, 1, FrAtNu, vect);
  FrMinC[2] = MinVector(vect, 1, FrAtNu);
  FrMaxC[2] = MaxDVector(vect, 1, FrAtNu);
  getColumnFrom2DArray(RoSFCo, 3, 1, FrAtNu, vect);
  FrMinC[3] = MinVector(vect, 1, FrAtNu);
  FrMaxC[3] = MaxDVector(vect, 1, FrAtNu);
  free_dvector(vect,1,FrAtNu);
/*======================================*/


/* Get the frag neighbour list (before some useful quantities)*/
  len.x = FrMaxC[1] - FrMinC[1];
  len.y = FrMaxC[2] - FrMinC[2];
  len.z = FrMaxC[3] - FrMinC[3];
  slen = (len.x>len.y) ? len.x : len.y;
  slen = (slen>len.z) ? slen : len.z;
  rscale_fr = 2.*(FrRmax + WaMoRa) + rslop;
  nstep_fr = (int) (( slen + 2.*(FrRmax + WaMoRa) ) / (rscale_fr) + 0.5)
              + 2;
  nstep_fr = ( ((nstep_fr >> 1) << 1) == nstep_fr) ?
             nstep_fr : nstep_fr + 1;
  nlist_fr=i3tensor(1,nstep_fr,1,nstep_fr,1,nstep_fr);
  list_fr=imatrix(1,MaxNeigh,1,nstep_fr*nstep_fr*nstep_fr);
  nn = Fr_neighlist(FrAtNu,RoSFCo,FrMinC,FrRad,WaMoRa,len,slen,
                    nlist_fr,list_fr,nstep_fr,&cbmid_fr,
                    &midg_fr,rscale_fr);

/* Superpose the S&R surfaces of the fragment alone and of the receptor
   neighbour atoms and obtain the buried points. They account for the desolvation */

/* Fragment Desolvation */
  nn = Fast_Desol(FrAtNu,ReCoor,FrRadOut,ReRadOut2,surfpt_fr,nsurf_fr,
                  pointsrf_fr,nlist_re,list_re,nstep_re,cbmid_re,midg_re,
                  rscale_re,FrSurf_deso,PFrDesoElec);

/* Receptor Desolvation */
  nn = Fast_Desol_Receptor(ReAtNu,RoSFCo,ReRadOut,FrRadOut2,surfpt_re,nsurf_re,
			   pointsrf_re,nlist_fr,list_fr,nstep_fr,cbmid_fr,midg_fr,
			   rscale_fr,ReSurf_deso,PReDesoElec,FrMinC,FrMaxC,ReCoor,FrRmax,WaMoRa);/* dbx check */

  free_i3tensor(nlist_fr,1,nstep_fr,1,nstep_fr,1,nstep_fr);
  free_imatrix(list_fr,1,MaxNeigh,1,nstep_fr*nstep_fr*nstep_fr);
/*  printf("\tFast Desol %lf\n",1e-6 * (clock()-ntime)); */
}

int Fr_neighlist(int FrAtNu,double **RoSFCo,double *FrMinC,double *FrRad,
                 double WaMoRa,struct point len,double slen,
                 int ***nlist,int **list,int nstep,struct point *Pcbmid,
                 int *Pmidg,double rscale)
/*########################################################################
Get the neighbour list fo the frag: set up a grid and then associate
each frag atom to a grid point
########################################################################*/

/*#######################################################################
int FrAtNu -------------- Tot # frag atoms
double **RoSFCo ---------- Frag coordinates in the seeded conformation
double FrMinC[4] --------- Min (along x,y,z) of RoSFCo
double FrMaxC[4] --------- Max (along x,y,z) of RoSFCo
double WaMoRa ----------- Radius of the water molecule
struct point len -------- FrMaxC_orig - FrMinC_orig
double slen ------------- Max dimension of the the grid box for the
                          frag neighbour list
int ****nlist ----------- nlist_fr[ix][iy][iz]: # of frag atoms associated with cube
                          grid point ix,iy,iz. It is a special grid created to
                          have a fast neighbour list for the fast desolvation
int ***list ------------- list[m][n(ix,iy,iz)]: given the grid
                          point ix,iy,iz "list" tells which frag atom numbers are
                          associated with this point (m goes from
                          1 to nlist_fr[ix][iy][iz] )
int nstep --------------- Dimension of the grid box for the frag neighbour list.
                          It is a cubic box of even elements on each side
struct point *Pcbmid ---- Coor of the center of the grid box for the
                          frag neighbour list
int *Pmidg -------------- nstep/2. + 1
double rscale ----------- 2.*(MaximumFragChargeRadius + WaMoRa) + rslop
######################################################################*/
{
  double *cbrdp,*cbrdp2;
  int iat,ix,iy,iz;
  struct point *ccrd,midgpt;

/* get some values for the cubing grid */
  Pcbmid->x = FrMinC[1] + len.x/2.;
  Pcbmid->y = FrMinC[2] + len.y/2.;
  Pcbmid->z = FrMinC[3] + len.z/2.;

  *Pmidg = nstep/2. + 1;
  midgpt.x = nstep/2. + 1;
  midgpt.y = nstep/2. + 1;
  midgpt.z = nstep/2. + 1;

 /* convert all atom coords to cubing grid coords (ccrd): */

  cbrdp=dvector(1,FrAtNu);
  cbrdp2=dvector(1,FrAtNu);
  ccrd=structpointvect(1,FrAtNu);

  for (iat=1;iat<=FrAtNu;iat++) {
    cbrdp[iat] = ( FrRad[iat] + WaMoRa ) / rscale;
    cbrdp2[iat] = cbrdp[iat] * cbrdp[iat];

    ccrd[iat].x = (RoSFCo[iat][1] - Pcbmid->x) / rscale + *Pmidg;
    ccrd[iat].y = (RoSFCo[iat][2] - Pcbmid->y) / rscale + *Pmidg;
    ccrd[iat].z = (RoSFCo[iat][3] - Pcbmid->z) / rscale + *Pmidg;
  }

 /* NOW GENERATE LIST OF ATOMS ASSOCIATED WITH EACH GRID POINT,
    BY TRUNCATION:
    keep track of max number of atoms associated with any grid point */

 /* initialize nlist: */
  for (ix=1;ix<=nstep;ix++) {
    for (iy=1;iy<=nstep;iy++) {
      for (iz=1;iz<=nstep;iz++) {
        nlist[ix][iy][iz] = 0;
      }
    }
  }

  for (iat=1;iat<=FrAtNu;iat++) {
/* generate truncated cube coords of each atom, and use as subscript */
    ix = (int) ccrd[iat].x;
    iy = (int) ccrd[iat].y;
    iz = (int) ccrd[iat].z;

/* number of atoms associated with cube grid point ix,iy,iz: */
    ++nlist[ix][iy][iz];

/* store index of atom associated with cube grid point ix,iy,iz: */
    list[nlist[ix][iy][iz]][nstep*nstep*(ix-1) + nstep*(iy-1) + iz]
    = iat;
  }

/* Free memory */
  free_structpointvect(ccrd,1,FrAtNu);
  free_dvector(cbrdp2,1,FrAtNu);
  free_dvector(cbrdp,1,FrAtNu);

  if (iat == FrAtNu+1 )
    return 1;
  else
    return 0;
}

int FragDesoSurf(int FrAtNu,double **FrCoor,double *FrPaCh,
                 double *FrVdWR,double *FrRad2,double *FrRadOut,
                 double *FrRadOut2,int Nsurfpt_fr,
                 struct point *surfpt_fr_orig,double WaMoRa,double GrSiSo,
                 double DielRe,double DielWa,double pi4,
                 double corr_fast_deso,double corr_re_desoco,
                 double **FrSurf_deso)
/*########################################################################
Set up a grid around the frag. Calculate the electric displacement
resulting from the frag on this grid. Finally calculate the frag
desolvation resulting from the removal of a sphere of
water having the center on all the surfpt_fr_orig SAS2 points
########################################################################*/

/*#######################################################################
int FrAtNu -------------- Tot # frag atoms
double **FrCoor ---------- Frag coordinates in the original location
double *FrPaCh ----------- Frag partial charges
double *FrVdWR ----------- Frag vdW radii
double *FrRad2 ---------- (Frag charge radii)^2
double *FrRadOut -------- Frag charge radii + WaMoRa
double *FrRadOut2 ------- (Frag charge radii + WaMoRa)^2
int Nsurfpt_fr ---------- Tot # of points over the frag SAS2
struct point *surfpt_fr_orig - Coor of points over frag SAS2 (obtained from
                               FrCoor coordinates)
double WaMoRa ----------- Radius of the water molecule
double GrSiSo ----------- Size of the 3D grid used for cont. electrostatics
double DielRe ----------- Dielectric constant of the rec (and of the fragments)
double DielWa ----------- Dielectric constant of the water
double pi4 -------------- 4 * greekpi
double corr_fast_deso --- Correction factor for fast elec desolvation
double corr_re_desoco --- Correction factor for slow elec desolvation
                          (coulomb approx.) (it is the same as for the rec)
double **FrSurf_deso ---- FrSurf_deso[n] = Desolvation of a sphere placed
                          on the nth point of the frag SAS2
######################################################################*/
{
  int ix,iy,iz,nn,NGridx,NGridy,NGridz,NGrid;
  double UnitVol,*XGrid,*YGrid,*ZGrid,***DeltaFrDeso;
  struct point Min,Max;
  char ***FrGridMat;
/*#######################################################################
int ix,iy,iz,nn --------- Multipurpose variables
int NGridx -------------- Tot # of frag grid points along x
int NGridy -------------- Tot # of frag grid points along y
int NGridz -------------- Tot # of frag grid points along z
int NGrid --------------- NGridx*NGridy*NGridz
double UnitVol ---------- Volume of the grid element
                          for cont. elec. = (GrSiSo)^3
double *XGrid ----------- X coor of the grid points
double *YGrid ----------- Y coor of the grid points
double *ZGrid ----------- Z coor of the grid points
double ****DeltaPrDeso -- Elec desolvation due to the occupation of a grid point
struct point Min -------- Min coor of the grid box
struct point Max -------- Max coor of the grid box
char ***FrGridMat ------- Matrix telling if a grid point is occupied by the
                          frag (o), empty (e), or if it belongs to the interface
                          between SAS and MS (s)
######################################################################*/

  /* Get the # grid pts needed to cover the frag molecule along the
     three axis */
  nn = get_Grid_Dim(FrAtNu,FrCoor,FrVdWR,WaMoRa,GrSiSo,WaMoRa,&NGridx,&NGridy,
                    &NGridz,&NGrid,&Min,&Max,&UnitVol);

  XGrid=dvector(1,NGridx);
  YGrid=dvector(1,NGridy);
  ZGrid=dvector(1,NGridz);
  /* Get the cartesian coor for the grid points */
  nn = Coor_Grid_Pts(GrSiSo,NGridx,NGridy,NGridz,Min,XGrid,YGrid,ZGrid);


/* Here in reality FrGridMat is a dummy variable: it is set to 'e'
   everywhere. In this way the function Calc_D_Coul works correctly and
   can be used as it is without modifications.
   In this particular case we do not actually need to know whic points
   are occupied by the frag */
  FrGridMat = c3tensor(1,NGridx+1,1,NGridy+1,1,NGridz+1);
  for (ix=1;ix<=NGridx+1;ix++)
    for (iy=1;iy<=NGridy+1;iy++)
      for (iz=1;iz<=NGridz+1;iz++)
        FrGridMat[ix][iy][iz] = 'e';
  DeltaFrDeso = d3tensor(1,NGridx,1,NGridy,1,NGridz);
  for (ix=1;ix<=NGridx;ix++)
    for (iy=1;iy<=NGridy;iy++)
      for (iz=1;iz<=NGridz;iz++)
        DeltaFrDeso[ix][iy][iz] = 0.0000000000000000;
/* Evaluation of the desolvation everywhere on the grid box (it is correct
   only in the points that are not occupied by the fragment, but for the
   fast desolvation we need only such points)  */
  nn = Calc_D_Coul(FrAtNu,FrCoor,FrRad2,Min,Max,FrPaCh,DielRe,DielWa,
                   GrSiSo,pi4,1,1,1,NGridx,NGridy,NGridz,
                   XGrid,YGrid,ZGrid,FrGridMat,UnitVol,corr_re_desoco,
                   DeltaFrDeso);

/* Fast method to evaluate fragment desolvation */
  *FrSurf_deso = dvector(1,Nsurfpt_fr);
  nn = Fast_Desol_Surf(Min,WaMoRa,GrSiSo,1,1,1,NGridx,NGridy,NGridz,
                      Nsurfpt_fr,surfpt_fr_orig,DeltaFrDeso,corr_fast_deso,
                      *FrSurf_deso);

  free_dvector(XGrid,1,NGridx);
  free_dvector(YGrid,1,NGridy);
  free_dvector(ZGrid,1,NGridz);
  free_c3tensor(FrGridMat,1,NGridx+1,1,NGridy+1,1,NGridz+1);
  free_d3tensor(DeltaFrDeso,1,NGridx,1,NGridy,1,NGridz);

  if ( ix == NGridx+1 )
    return 1;
  else
    return 0;
}

int Fast_Desol(const int AtNu,double **Coor,double *RadOut,double *RadOut2,
               struct point *surfpt,int *nsurf,int *pointsrf,int ***nlist,
               int **list,const int nstep,struct point cbmid,const int midg,const double rscale,
               double *Surf_deso,double *PDesoElec)
/*########################################################################
Evaluate the rec (frag) desolvation looking at which SAS2 points
are buried upon binding
########################################################################*/

/*#######################################################################
intrAtNu ---------------- Tot # rec (frag) atoms
double **Coor ------------ Rec (frag) coordinates in the original location
double *RadOut ---------- Rec (frag) charge radii + WaMoRa
double *RadOut2 --------- (Rec (frag) charge radii + WaMoRa)^2
int Nsurfpt_fr ---------- Tot # of points over the frag SAS2
struct point *surfpt ---- Coor of points over rec (frag) SAS2
                          (for the frag it is obtained from RoSFCo coordinates)
int *nsurf -------------- nsurf[n] = amount of SAS2 surface points
                          generated by rec (frag) atom n
int *pointsrf ----------- pointsrf[n] = first rec (frag) SAS2 point (in the
                          list surfpt) that is generated by rec (frag) atom n
int ***nlist ------------ nlist[ix][iy][iz]: # of rec (frag) atoms associated
                          with cube grid point ix,iy,iz. It is a special grid
                          created to have a fast neighbour list for
                          the fast desolvation
int **list -------------- list[m][n(ix,iy,iz)]: given the grid
                          point ix,iy,iz "list" tells which rec (frag) atom
                          numbers are associated with this point (m goes from
                          1 to nlist[ix][iy][iz] )
int nstep --------------- Dimension of the grid box for the rec (frag) neighbour
                          list. It is a cubic box of even elements on each side
struct point cbmid ------ Coor of the center of the grid box for the
                          rec (frag) neighbour list
int midg ---------------- nstep/2. + 1
double rscale ----------- 2.*(Maximum(Rec/Frag)ChargeRadius + WaMoRa) + rslop
double **Surf_deso ------ Surf_deso[n] = rec (frag) desolvation operated by
                          a sphere placed on the nth point of the rec (frag) SAS2
double *PDesoElec ------- Rec (frag) elec desolvation
######################################################################*/
{
  double d2;
  int iat,ix,iy,iz,isph,nx,ny,nz,inayb,listmp;
  struct point sphpt;
  int xlast; /* index of last atom which was close to a surface point -> check the same atom again */
#ifdef OMP
  float test = 0;  /* -> needed for OMP version */
#endif

  /*
     "xlast" modification -> small speedup only for fragment -> thus function split into two functions for
     receptor and fragment
   */
  xlast = -1;

  /* dey checking */
  *PDesoElec = 0.;

/* LOOP OVER ATOMS; FOR EACH ATOM, LOOP OVER SAS POINTS
   OF ATOM; FOR EACH SAS POINT, LOOP OVER NEIGHBORING ATOMS
   (AS DETERMINED FROM LIST ARRAY); IF CURRENT SURFACE POINT IS
   EXCLUDED BY A NEIGHBOR, ACCOUNT THE CONTRIBUTION TO THE DESOLVATION. */

/* Begin loop over atoms */
/* works... but has long waiting periods -> is similar for guided or dynamic scheduling */
#ifdef OMP
#pragma omp parallel for schedule(guided) default(shared) private(d2,ix,iy,iz,isph,nx,ny,nz,inayb,listmp,sphpt) reduction(+:test) lastprivate(iat)
#endif
  for (iat=1;iat<=AtNu;iat++) {
/* Begin loop over surface point of atom iat: get the cubing coords
   of every surface point */
    for (isph=pointsrf[iat];isph<=pointsrf[iat] +
         nsurf[iat] - 1 ; isph++) {
      sphpt.x = (surfpt[isph].x - cbmid.x)/rscale + midg;
      sphpt.y = (surfpt[isph].y - cbmid.y)/rscale + midg;
      sphpt.z = (surfpt[isph].z - cbmid.z)/rscale + midg;
      nx = (int) (sphpt.x + 0.5);
      ny = (int) (sphpt.y + 0.5);
      nz = (int) (sphpt.z + 0.5);

      if(xlast >= 0 ) /* test */
 	{
	  /* instead of looping over all atoms stored in the 8 grid cube points,   */
	  /* check the last atom close enough (see below) to knock out surface point   */
	  /* and first check this particular atom  */

 	  d2 = (surfpt[isph].x - Coor[xlast][1])*
 	    (surfpt[isph].x - Coor[xlast][1])+
 	    (surfpt[isph].y - Coor[xlast][2])*
 	    (surfpt[isph].y - Coor[xlast][2])+
 	    (surfpt[isph].z - Coor[xlast][3])*
 	    (surfpt[isph].z - Coor[xlast][3]);
 	  if (d2 < RadOut2[xlast]) {
 #ifdef OMP
 	    test += Surf_deso[isph];
 #else
 	    *PDesoElec += Surf_deso[isph];
 #endif
 	    continue;
 	  }
 	}
       else {  xlast = -1;}

/* loop over neighbor grid points.  The cubing grid is set up so that the
   only atoms which could "knock out" this possible protein surface point
   are those associated with the atom's own grid point, or that grid
   point's neighbors. */
      /*
	 next three loops iterate over two elements each -> 8 grid points surrounding sphere center
       */
      for (iz=nz-1;iz<=nz;iz++) {
        if (iz>=1 && iz <= nstep) {

          for (iy=ny-1;iy<=ny;iy++) {
            if (iy>=1 && iy <= nstep) {

              for (ix=nx-1;ix<=nx;ix++) {
                if (ix>=1 && ix <= nstep) {
		  /* loop over atoms associated with current grid point: */
                  for (inayb=1;inayb<=nlist[ix][iy][iz];inayb++) {
                    listmp =
                          list[inayb][nstep*nstep*(ix-1) + nstep*(iy-1) + iz];
                    d2 = (surfpt[isph].x - Coor[listmp][1])*
                         (surfpt[isph].x - Coor[listmp][1])+
                         (surfpt[isph].y - Coor[listmp][2])*
                         (surfpt[isph].y - Coor[listmp][2])+
                         (surfpt[isph].z - Coor[listmp][3])*
                         (surfpt[isph].z - Coor[listmp][3]);
                    if (d2 < RadOut2[listmp]) {
		      xlast=listmp;  /* remember atom which knocked out surface point */
#ifdef OMP
		      test += Surf_deso[isph]; /* OMP v. */
#else
		      *PDesoElec += Surf_deso[isph];
#endif
                      goto newpoint;
                    }
/* end loop over atoms of current neighbor grid point (inayb): */
                  }
/* end loops over neighbor grid points for this possible surface point:
   ix loop: */
                }
              }
/* iy loop: */
            }
          }
/* iz loop: */
        }
      }
newpoint:
      continue;
    }
  }

#ifdef OMP
  *PDesoElec = test;
#endif
  if (iat == AtNu+1 )
    return 1;
  else
    return 0;
}


int Fast_Desol_Receptor(const int AtNu,double **Coor,double *RadOut,double *RadOut2,
			struct point *surfpt,int *nsurf,int *pointsrf,int ***nlist,
			int **list,const int nstep,struct point cbmid,const int midg,const double rscale,
			double *Surf_deso,double *PDesoElec,
			double * minC,double *maxC, double ** xcoor,double FrRmax,double WaMoRa)
/*########################################################################
  Evaluate the rec (frag) desolvation looking at which SAS2 points
  are buried upon binding
  ########################################################################*/

/*#######################################################################
  intrAtNu ---------------- Tot # rec (frag) atoms
  double **Coor ------------ Rec (frag) coordinates in the original location
  double *RadOut ---------- Rec (frag) charge radii + WaMoRa
  double *RadOut2 --------- (Rec (frag) charge radii + WaMoRa)^2
  int Nsurfpt_fr ---------- Tot # of points over the frag SAS2
  struct point *surfpt ---- Coor of points over rec (frag) SAS2
  (for the frag it is obtained from RoSFCo coordinates)
  int *nsurf -------------- nsurf[n] = amount of SAS2 surface points
  generated by rec (frag) atom n
  int *pointsrf ----------- pointsrf[n] = first rec (frag) SAS2 point (in the
  list surfpt) that is generated by rec (frag) atom n
  int ***nlist ------------ nlist[ix][iy][iz]: # of rec (frag) atoms associated
  with cube grid point ix,iy,iz. It is a special grid
  created to have a fast neighbour list for
  the fast desolvation
  int **list -------------- list[m][n(ix,iy,iz)]: given the grid
  point ix,iy,iz "list" tells which rec (frag) atom
  numbers are associated with this point (m goes from
  1 to nlist[ix][iy][iz] )
  int nstep --------------- Dimension of the grid box for the rec (frag) neighbour
  list. It is a cubic box of even elements on each side
  struct point cbmid ------ Coor of the center of the grid box for the
  rec (frag) neighbour list
  int midg ---------------- nstep/2. + 1
  double rscale ----------- 2.*(Maximum(Rec/Frag)ChargeRadius + WaMoRa) + rslop
  double **Surf_deso ------ Surf_deso[n] = rec (frag) desolvation operated by
  a sphere placed on the nth point of the rec (frag) SAS2
  double *PDesoElec ------- Rec (frag) elec desolvation
  ######################################################################*/
{
  double d2;
  int iat,ix,iy,iz,isph,nx,ny,nz,inayb,listmp;
  struct point sphpt;
  double xscale,tmpscale;/* dey check*/
#ifdef OMP
  float test = 0;  /* -> needed for OMP version */
#endif

  /* about 90% of nlist[ix][iy][iz] are empty ... -> to optimize  */
  /*
    dey
    dbx to do  -> loop directly over surface points
    surfpt_re_deso
  */

  /* dey checking */
  *PDesoElec = 0.;
  xscale = FrRmax + WaMoRa;
  /* LOOP OVER ATOMS; FOR EACH ATOM, LOOP OVER SAS POINTS
     OF ATOM; FOR EACH SAS POINT, LOOP OVER NEIGHBORING ATOMS
     (AS DETERMINED FROM LIST ARRAY); IF CURRENT SURFACE POINT IS
     EXCLUDED BY A NEIGHBOR, ACCOUNT THE CONTRIBUTION TO THE DESOLVATION. */

  /* Begin loop over atoms */
  /* works... but has long waiting periods -> even with dynamic or guided scheduling.. */
#ifdef OMP
#pragma omp parallel for schedule(guided) default(shared) private(d2,ix,iy,iz,isph,nx,ny,nz,inayb,listmp,sphpt) reduction(+:test) lastprivate(iat)
#endif
  for (iat=1;iat<=AtNu;iat++) {

    tmpscale = RadOut[iat] + xscale + 0.5; /*  -> check margin 0.5 */

    /*
      check if current atom is within reach of any fragment atom using minimum/maximum coordinates of fragment (+2 * water radius)
      -> can speed up lookup quite drastically
    */
     if( xcoor[iat][1] + tmpscale > minC[1] &&
	 xcoor[iat][2] + tmpscale > minC[2] &&
	 xcoor[iat][3] + tmpscale > minC[3] &&
	 xcoor[iat][1] - tmpscale < maxC[1] &&
	 xcoor[iat][2] - tmpscale < maxC[2] &&
	 xcoor[iat][3] - tmpscale < maxC[3] )
       {

	/* Begin loop over surface point of atom iat: get the cubing coords
	   of every surface point */
	for (isph=pointsrf[iat];isph<=pointsrf[iat] +
	       nsurf[iat] - 1 ; isph++) {
	  sphpt.x = (surfpt[isph].x - cbmid.x)/rscale + midg;
	  sphpt.y = (surfpt[isph].y - cbmid.y)/rscale + midg;
	  sphpt.z = (surfpt[isph].z - cbmid.z)/rscale + midg;
	  nx = (int) (sphpt.x + 0.5);
	  ny = (int) (sphpt.y + 0.5);
	  nz = (int) (sphpt.z + 0.5);

	  /* loop over neighbor grid points.  The cubing grid is set up so that the
	     only atoms which could "knock out" this possible protein surface point
	     are those associated with the atom's own grid point, or that grid
	     point's neighbors. */
	  /* tmp  dbx  remove
	     next three loops iterate over two elements each == 8 -> grid points surrounding
	     sphere center
	  */

	  for (iz=nz-1;iz<=nz;iz++) {
	    if (iz>=1 && iz <= nstep) {

	      for (iy=ny-1;iy<=ny;iy++) {
		if (iy>=1 && iy <= nstep) {

		  for (ix=nx-1;ix<=nx;ix++) {
		    if (ix>=1 && ix <= nstep) {
		      /* loop over atoms associated with current grid point: */
		      for (inayb=1;inayb<=nlist[ix][iy][iz];inayb++) {
			listmp =
                          list[inayb][nstep*nstep*(ix-1) + nstep*(iy-1) + iz];
			d2 = (surfpt[isph].x - Coor[listmp][1])*
			  (surfpt[isph].x - Coor[listmp][1])+
			  (surfpt[isph].y - Coor[listmp][2])*
			  (surfpt[isph].y - Coor[listmp][2])+
			  (surfpt[isph].z - Coor[listmp][3])*
			  (surfpt[isph].z - Coor[listmp][3]);
			if (d2 < RadOut2[listmp]) {
#ifdef OMP
			  test += Surf_deso[isph]; /* OMP v. */
#else
			  *PDesoElec += Surf_deso[isph];
#endif
			  goto newpoint;
			}
			/* end loop over atoms of current neighbor grid point (inayb): */
		      }
		      /* end loops over neighbor grid points for this possible surface point:
			 ix loop: */
		    }
		  }
		  /* iy loop: */
		}
	      }
	      /* iz loop: */
	    }
	  }
	newpoint:
	  continue;
	}
      } /* new if statement */
  }
#ifdef OMP
  *PDesoElec = test;
#endif
  if (iat == AtNu+1 )
    return 1;
  else
    return 0;
}
